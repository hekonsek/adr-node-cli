# Use Commander as library for Node-based command-line tools

## Context

We are building Node-based command-line tools and need a standard library for parsing arguments, defining commands/subcommands, and generating help output. The library should be mature, well-documented, and widely adopted in the Node ecosystem.

## Decision

We will use [commander.js](https://github.com/tj/commander.js) as the default CLI library for all new Node-based command-line tools in this project.

Commander is currently the most popular library for Node-based CLIs and offers a simple, declarative API for defining commands, options, and help text.

## Consequences

Pros:
* ✅ Consistent CLI style and behavior across all tools.
* ✅ Faster development thanks to Commander’s concise API and good documentation.
* ✅ Easier onboarding for new contributors familiar with Commander.

Cons:
* ❌ Tight coupling to Commander’s API; switching to another library later will require refactoring.
* ❌ We inherit Commander’s limitations and release cycle.

## Alternatives considered

* **yargs** – Powerful and mature, but the configuration style is more verbose and less intuitive. Much less popular than Commander.
* **oclif** – Very capable framework, but heavier-weight and better suited for large CLIs with plugins; overkill for our current needs. Much less popular than Commander.
* **Custom argument parsing / util.parseArgs** – Maximum flexibility, but would require more effort to implement and maintain, with no clear benefit over a standard library.


# ADR: Separate command-line logic from core/domain/business logic

## Context

Many Node-based CLI tools (especially those scaffolded or generated by AI tools) mix CLI parsing logic (Commander.js, Yargs, oclif, etc.) with the core/domain/business logic. This makes the codebase hard to understand and test, couples the domain to a specific CLI framework, and complicates reuse (e.g., using the same logic from HTTP APIs, background jobs, or other CLIs).

## Decision

We will strictly separate CLI parsing from core/domain/business logic:

- `index.ts` (or equivalent entrypoint) will contain only:
  - CLI setup and argument parsing (Commander.js, Yargs, oclif, etc.).
  - Wiring of parsed arguments to core/domain/business services.
- All core/domain/business logic will live in dedicated modules/packages that:
  - Expose clear classes, functions, or use-cases.
  - Have no dependency on CLI libraries.
- CLI libraries must be referenced only from the entrypoint (`index.ts`), not from core/domain modules.

## Consequences

Pros:
* ✅ **Readability**: It is much easier to understand CLI parsing and core logic.
* ✅ **Testability**: Core logic can be unit-tested without bootstrapping a CLI or mocking `process.argv`.
* ✅ **Reusability**: The same logic can be called from other interfaces (HTTP, queues, other CLIs).
* ✅ **Replaceable CLI framework**: We can switch from Commander.js to another library with minimal changes (mostly in `index.ts`).
* ✅ **Cleaner architecture**: Clear separation of concerns and easier onboarding for new contributors.

Cons:
* ❌ Slightly more initial boilerplate (wiring code in `index.ts` to domain modules).
* ❌ Requires discipline and code reviews to prevent CLI-related logic from leaking into domain code.

## Alternatives considered

- **Keep CLI and business logic mixed in one file**. Simpler initial setup, but leads to tightly coupled, hard-to-test, and hard-to-evolve codebases.